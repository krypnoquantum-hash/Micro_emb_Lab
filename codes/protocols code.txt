INDEX:

1.uart(d1-d0 ,d0-d1,gnd-gnd)
2.spi(11-11,12-12,13-13,10-10,gnd-gnd)
3.i2c(A4-A4,A5-A5,gnd-gnd)
4.usb
5.bitstream(master(d1)-slave(d0),gnd-gnd)

////////////////////////////////////////////////////////////////
//UART-master(gnd-gnd,tns-reciver)

void setup() {
  Serial.begin(9600); // UART starts at 9600 baud
  delay(1000);        // Give time for Serial to initialize
}

void loop() {
  Serial.println("Hello from Master"); // Send message
  delay(1000);                         // Wait 1 second
}

//Uart-slave

void setup() {
  Serial.begin(9600); // Same baud rate as master
}

void loop() {
  if (Serial.available()) {
    String incoming = Serial.readStringUntil('\n');
    Serial.print("Received: ");
    Serial.println(incoming);
  }
}



//////////////////////////////////////////////////////////////////


//SPI 0master

#include <SPI.h>

void setup() {
  // Start Serial for debugging
  Serial.begin(9600);

  // Set SS pin as output
  pinMode(10, OUTPUT);
  digitalWrite(10, HIGH); // Deselect slave

  SPI.begin(); // Initialize SPI as Master
}

void loop() {
  digitalWrite(10, LOW); // Select slave

  char msg[] = "Hello";
  for (int i = 0; i < sizeof(msg); i++) {
    SPI.transfer(msg[i]); // Send character
  }

  digitalWrite(10, HIGH); // Deselect slave

  Serial.println("Sent: Hello");
  delay(1000); // Wait 1 second
}


//SPI - slave

#include <SPI.h>

volatile boolean received = false;
char receivedChar;

void setup() {
  Serial.begin(9600);
  pinMode(MISO, OUTPUT);   // Set MISO as OUTPUT
  SPCR |= _BV(SPE);        // Enable SPI in slave mode
  SPI.attachInterrupt();   // Enable interrupt on SPI transfer complete
}

ISR(SPI_STC_vect) {
  receivedChar = SPDR;     // Read received byte
  received = true;
}

void loop() {
  if (received) {
    Serial.print("Received: ");
    Serial.println(receivedChar);
    received = false;
  }
}

//////////////////////////////////////////////////////////////////////////////


I2C-master

#include <Wire.h>

void setup() {
  Wire.begin(); // Join I2C bus as master
  Serial.begin(9600);
  delay(1000); // Give some time for setup
}

void loop() {
  Wire.beginTransmission(8); // Address of slave (must match slave's Wire.begin(8))
  Wire.write("Hello from Master");
  Wire.endTransmission();

  Serial.println("Sent to Slave: Hello from Master");

  delay(1000); // Send every 1 second
}



I2c-slave

#include <Wire.h>

void setup() {
  Wire.begin(8);        // Set I2C address to 8
  Wire.onReceive(receiveEvent);
  Serial.begin(9600);
}

void loop() {
  // Do nothing in loop
}

void receiveEvent(int bytes) {
  while (Wire.available()) {
    char c = Wire.read();
    Serial.print(c);
  }
  Serial.println();
}

////////////////////////////////////////////////////////////

USB


void setup() {
  Serial.begin(9600);          // Start serial communication at 9600 baud
  Serial.println("USB Serial Communication Started!");
  Serial.println("Type something below:");
}

void loop() {
  // Check if data is available from the computer
  if (Serial.available() > 0) {
    char incomingChar = Serial.read();  // Read one character
    Serial.print("You typed: ");
    Serial.println(incomingChar);       // Send it back (echo)
  }
}


///////////////////////////////////////////////////////////////


Bit-stream


Master 

//MASTER
// Transmitter Arduino (sends bitstream of length 5-9)
void setup() {
  Serial.begin(9600);
  delay(1000);
}

void loop() {
  // Send a few example binary sequences (between 5–9 bits)
  // Let's say we send: 10101 (5 bits), 1100110 (7 bits), etc.

  byte bitSequences[] = {
    B10101,     // 5 bits: 10101
    B1001101,   // 7 bits: 1001101
    
  };
  
  byte lengths[] = {5, 7};  // Bit lengths of above

  for (int s = 0; s < 2; s++) {
    byte data = bitSequences[s];
    byte len = lengths[s];

    // Send the length first, so receiver knows how many bits to expect
    Serial.write(len);     // Send data length
    Serial.write(data);    // Send raw data
    delay(1000);           // Wait before next
  }

  delay(5000); // Wait 5 seconds and repeat
}

Slave

//SLAVE
// Receiver Arduino with UART frame simulation and Serial Plotter output
void setup() {
  Serial.begin(9600);
  delay(1000);
  Serial.println("Start\tBit0\tBit1\tBit2\tBit3\tBit4\tBit5\tBit6\tBit7\tParity\tStop");
}

void loop() {
  if (Serial.available() >= 2) {
    byte len = Serial.read();     // First byte = number of bits (5–9)
    byte data = Serial.read();    // Second byte = data bits

    // Extract data bits into array
    byte bits[9] = {0};
    for (byte i = 0; i < len; i++) {
      bits[i] = (data >> i) & 0x01;
    }

    // --- UART Frame Construction ---
    byte startBit = 0;
    byte stopBit = 1;

    // Calculate even parity
    byte parity = 0;
    for (byte i = 0; i < len; i++) {
      parity ^= bits[i];  // XOR to find parity
    }

    // --- Serial Monitor Output ---
    Serial.print("UART Frame: ");
    Serial.print(startBit);
    Serial.print(" ");

    for (byte i = 0; i < len; i++) {
      Serial.print(bits[i]);
      Serial.print(" ");
    }

    Serial.print(parity);
    Serial.print(" ");
    Serial.print(stopBit);
    Serial.println();

    // --- Serial Plotter Output ---
    Serial.print(startBit);
    Serial.print('\t');

    for (byte i = 0; i < 8; i++) {  // Max bits shown is 8 for plot stability
      if (i < len)
        Serial.print(bits[i]);
      else
        Serial.print(0); // Fill empty slots with 0
      Serial.print('\t');
    }

    Serial.print(parity);
    Serial.print('\t');
    Serial.print(stopBit);
    Serial.println();
  }
}


/////////////////////////////////////////////////////////


//keypad

unsigned short kp=0;

char keypadPort at PORTB;

void main(){

    TRISA=0x00;

    PORTA=0x00;

    Keypad_Init();

    while(1){

        do{

            kp=Keypad_Key_Press();

        }

        while(!kp);

            if(kp<=3){

                PORTA=kp;

            }

            else if(kp>3 && kp<=7){

                PORTA=kp-1;

            }

            else if(kp>8 && kp<=11){

                PORTA=kp-2;

            }

    }

}


////////////////////////////////////////////////////////////////////

// IIR FILTER Design

float xn1=0;//input
float yn1=0;//output

void setup() {
  Serial.begin(9600);
}

void loop() {
  
  float t= micros()/1.0e6;
  float xn= sin(2*2*PI*t)+0.2*sin(2*50*PI*t);
  float yn=0.960*yn1+0.0155*xn+0.0155*xn1;

  float max_xn=1.2;
  xn/=max_xn;

  Serial.print(xn);
  Serial.print(" ");
  Serial.print(yn);

  xn1=xn;
  yn1=yn;
  delay(1);

}

// FIR FILTER Design

const int N=2;
float xn_buffer[N];
float b[N]={0.0155,0.0155};

void setup() {
  Serial.begin(9600);
}

void loop() {
  
  float t= micros()/1.0e6;
  float xn= sin(2*2*PI*t)+0.2*sin(2*50*PI*t);
  
  xn=xn/1.2;

  for(int i=N-1;i>0;i--){
    xn_buffer[i]=xn_buffer[i-1];
  }

  xn_buffer[0]=xn;

  float yn=0;
  for(int i=0;i<N;i++){
    yn+=b[i]*xn_buffer[i];
  }
  yn=yn*15;

  Serial.print(xn);
  Serial.print(" ");
  Serial.print(yn);

 
  delay(1);

}















